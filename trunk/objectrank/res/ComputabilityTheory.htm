<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0068)http://en.wikipedia.org/wiki/Computability_theory_(computer_science) -->
<HTML lang=en dir=ltr xml:lang="en" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>Computability theory (computer science) - Wikipedia, the free encyclopedia</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="MSHTML 6.00.6000.16705" name=GENERATOR>
<META 
content="Computability theory (computer science),Abstract machine,Alan Turing,Alonzo Church,Automata theory,Christos Papadimitriou,Church-Turing thesis,Computability logic,Computational complexity theory,Computer science,Concurrency (computer science)" 
name=keywords><LINK title="Edit this page" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit" 
type=application/x-wiki rel=alternate><LINK href="/favicon.ico" 
rel="shortcut icon"><LINK href="http://en.wikipedia.org/apple-touch-icon.png" 
rel=apple-touch-icon><LINK title="Wikipedia (en)" href="/w/opensearch_desc.php" 
type=application/opensearchdescription+xml rel=search><LINK 
href="http://www.gnu.org/copyleft/fdl.html" rel=copyright><LINK 
title="Wikipedia RSS Feed" 
href="http://en.wikipedia.org/w/index.php?title=Special:RecentChanges&amp;feed=rss" 
type=application/rss+xml rel=alternate><LINK title="Wikipedia Atom Feed" 
href="http://en.wikipedia.org/w/index.php?title=Special:RecentChanges&amp;feed=atom" 
type=application/atom+xml rel=alternate><LINK media=screen 
href="ComputabilityTheory_files/shared.css" type=text/css rel=stylesheet><LINK 
media=print href="ComputabilityTheory_files/commonPrint.css" type=text/css 
rel=stylesheet><LINK media=screen href="ComputabilityTheory_files/main.css" 
type=text/css rel=stylesheet><LINK media=handheld 
href="ComputabilityTheory_files/main(1).css" type=text/css rel=stylesheet><!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE50Fixes.css?179" type="text/css" media="screen" /><![endif]--><!--[if IE 5.5000]><link rel="stylesheet" href="/skins-1.5/monobook/IE55Fixes.css?179" type="text/css" media="screen" /><![endif]--><!--[if IE 6]><link rel="stylesheet" href="/skins-1.5/monobook/IE60Fixes.css?179" type="text/css" media="screen" /><![endif]--><!--[if IE 7]><LINK 
media=screen href="ComputabilityTheory_files/IE70Fixes.css" type=text/css 
rel=stylesheet><![endif]--><LINK href="ComputabilityTheory_files/index.css" 
type=text/css rel=stylesheet><LINK media=print 
href="ComputabilityTheory_files/index(1).css" type=text/css rel=stylesheet><LINK 
media=handheld href="ComputabilityTheory_files/index(2).css" type=text/css 
rel=stylesheet><LINK href="ComputabilityTheory_files/index(3).css" type=text/css 
rel=stylesheet><LINK href="ComputabilityTheory_files/index(4).css" type=text/css 
rel=stylesheet><!--[if lt IE 7]><script type="text/javascript" src="/skins-1.5/common/IEFixes.js?179"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
<SCRIPT type=text/javascript>/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Computability_theory_(computer_science)";
		var wgTitle = "Computability theory (computer science)";
		var wgAction = "view";
		var wgArticleId = "442136";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = "224042373";
		var wgVersion = "1.14alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/</SCRIPT>

<SCRIPT src="ComputabilityTheory_files/wikibits.js" type=text/javascript><!-- wikibits js --></SCRIPT>
<!-- Head Scripts -->
<SCRIPT src="ComputabilityTheory_files/ajax.js" type=text/javascript></SCRIPT>

<SCRIPT src="ComputabilityTheory_files/mwsuggest.js" 
type=text/javascript></SCRIPT>

<SCRIPT src="ComputabilityTheory_files/index.php" type=text/javascript><!-- site js --></SCRIPT>
</HEAD>
<BODY 
class="mediawiki ltr ns-0 ns-subject page-Computability_theory_computer_science skin-monobook">
<DIV id=globalWrapper>
<DIV id=column-content>
<DIV id=content><A id=top name=top></A>
<DIV id=siteNotice>
<SCRIPT language=JavaScript type=text/javascript>
<!--
document.writeln("\x3cp\x3e\x3c/p\x3e\n");
-->
</SCRIPT>
</DIV>
<H1 class=firstHeading>Computability theory (computer science)</H1>
<DIV id=bodyContent>
<H3 id=siteSub>From Wikipedia, the free encyclopedia</H3>
<DIV id=contentSub></DIV>
<DIV id=jump-to-nav>Jump to: <A 
href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#column-one">navigation</A>, 
<A 
href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#searchInput">search</A></DIV><!-- start content -->
<DIV class=dablink>For the branch of mathematical logic called computability 
theory, see <A title="Recursion theory" 
href="http://en.wikipedia.org/wiki/Recursion_theory">Recursion theory</A>.</DIV>
<P>In <A title="Computer science" 
href="http://en.wikipedia.org/wiki/Computer_science">computer science</A>, 
<B>computability theory</B> is the branch of the <A 
title="Theory of computation" 
href="http://en.wikipedia.org/wiki/Theory_of_computation">theory of 
computation</A> that studies which problems are computationally solvable using 
different <A title="Model of computation" 
href="http://en.wikipedia.org/wiki/Model_of_computation">models of 
computation</A>.</P>
<P>Computability theory differs from the related discipline of <A 
title="Computational complexity theory" 
href="http://en.wikipedia.org/wiki/Computational_complexity_theory">computational 
complexity theory</A>, which deals with the question of how efficiently a 
problem can be solved, rather than whether it is solvable at all.</P>
<TABLE class=toc id=toc summary=Contents>
  <TBODY>
  <TR>
    <TD>
      <DIV id=toctitle>
      <H2>Contents</H2></DIV>
      <UL>
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Introduction"><SPAN 
        class=tocnumber>1</SPAN> <SPAN class=toctext>Introduction</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Formal_models_of_computation"><SPAN 
        class=tocnumber>2</SPAN> <SPAN class=toctext>Formal models of 
        computation</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Power_of_automata"><SPAN 
        class=tocnumber>3</SPAN> <SPAN class=toctext>Power of 
        automata</SPAN></A> 
        <UL>
          <LI class=toclevel-2><A 
          href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Power_of_finite_state_machines"><SPAN 
          class=tocnumber>3.1</SPAN> <SPAN class=toctext>Power of finite state 
          machines</SPAN></A> 
          <LI class=toclevel-2><A 
          href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Power_of_pushdown_automata"><SPAN 
          class=tocnumber>3.2</SPAN> <SPAN class=toctext>Power of pushdown 
          automata</SPAN></A> 
          <LI class=toclevel-2><A 
          href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Power_of_Turing_machines"><SPAN 
          class=tocnumber>3.3</SPAN> <SPAN class=toctext>Power of Turing 
          machines</SPAN></A> 
          <UL>
            <LI class=toclevel-3><A 
            href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#The_halting_problem"><SPAN 
            class=tocnumber>3.3.1</SPAN> <SPAN class=toctext>The halting 
            problem</SPAN></A> 
            <LI class=toclevel-3><A 
            href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Beyond_recursive_languages"><SPAN 
            class=tocnumber>3.3.2</SPAN> <SPAN class=toctext>Beyond recursive 
            languages</SPAN></A> </LI></UL></LI></UL>
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Concurrency-based_models"><SPAN 
        class=tocnumber>4</SPAN> <SPAN class=toctext>Concurrency-based 
        models</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Unreasonable_models_of_computation"><SPAN 
        class=tocnumber>5</SPAN> <SPAN class=toctext>Unreasonable models of 
        computation</SPAN></A> 
        <UL>
          <LI class=toclevel-2><A 
          href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Infinite_execution"><SPAN 
          class=tocnumber>5.1</SPAN> <SPAN class=toctext>Infinite 
          execution</SPAN></A> 
          <LI class=toclevel-2><A 
          href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Oracle_machines"><SPAN 
          class=tocnumber>5.2</SPAN> <SPAN class=toctext>Oracle 
          machines</SPAN></A> 
          <LI class=toclevel-2><A 
          href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#Limits_of_hyper-computation"><SPAN 
          class=tocnumber>5.3</SPAN> <SPAN class=toctext>Limits of 
          hyper-computation</SPAN></A> </LI></UL>
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#History_of_computability_theory"><SPAN 
        class=tocnumber>6</SPAN> <SPAN class=toctext>History of computability 
        theory</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#See_also"><SPAN 
        class=tocnumber>7</SPAN> <SPAN class=toctext>See also</SPAN></A> 
        <LI class=toclevel-1><A 
        href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)#References"><SPAN 
        class=tocnumber>8</SPAN> <SPAN class=toctext>References</SPAN></A> 
      </LI></UL></TD></TR></TBODY></TABLE>
<SCRIPT type=text/javascript>
//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>
</SCRIPT>

<P><A id=Introduction name=Introduction></A></P>
<H2><SPAN class=editsection>[<A title="Edit section: Introduction" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=1">edit</A>]</SPAN> 
<SPAN class=mw-headline>Introduction</SPAN></H2>
<P>A central question of computer science is to address the limits of computing 
devices. One approach to addressing this question is understanding the problems 
we can use computers to solve. Modern computing devices often seem to possess 
infinite capacity for calculation, and it's easy to imagine that, given enough 
time, we might use computers to solve any problem. However, it is possible to 
show clear limits to the ability of computers, even given arbitrarily vast 
computational resources, to solve even seemingly simple problems. Problems are 
formally expressed as a decision problem which is to construct a mathematical 
function that for each input returns either <TT>0</TT> or <TT>1</TT>. If the 
value of the function on the input is <TT>0</TT> then the answer is "no" and 
otherwise the answer is "yes".</P>
<P>To explore this area, computer scientists invented <A title="Automata theory" 
href="http://en.wikipedia.org/wiki/Automata_theory">automata theory</A> which 
addresses problems such as the following: Given a <A title="Formal language" 
href="http://en.wikipedia.org/wiki/Formal_language">formal language</A>, and a 
string, is the string a member of that language? This is a somewhat esoteric way 
of asking this question, so an example is illuminating. We might define our 
language as the set of all strings of digits which represent a <A 
title="Prime number" href="http://en.wikipedia.org/wiki/Prime_number">prime 
number</A>. To ask whether an input string is a member of this language is 
equivalent to asking whether the number represented by that input string is 
prime. Similarly, we define a language as the set of all <A title=Palindrome 
href="http://en.wikipedia.org/wiki/Palindrome">palindromes</A>, or the set of 
all strings consisting only of the letter 'a'. In these examples, it is easy to 
see that constructing a computer to solve one problem is easier in some cases 
than in others.</P>
<P>But in what real sense is this observation true? Can we define a formal sense 
in which we can understand how hard a particular problem is to solve on a 
computer? It is the goal of computability theory of automata to answer just this 
question.</P>
<P><A id=Formal_models_of_computation name=Formal_models_of_computation></A></P>
<H2><SPAN class=editsection>[<A 
title="Edit section: Formal models of computation" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=2">edit</A>]</SPAN> 
<SPAN class=mw-headline>Formal models of computation</SPAN></H2>
<P>In order to begin to answer the central question of automata theory, it is 
necessary to define in a formal way what an automaton is. There are a number of 
useful models of automata. Some widely known models are:</P>
<DL>
  <DT><A class=mw-redirect title="Deterministic finite state machine" 
  href="http://en.wikipedia.org/wiki/Deterministic_finite_state_machine">Deterministic 
  finite state machine</A> 
  <DD>Also called a deterministic finite automaton (DFA), or simply a finite 
  state machine. All real computing devices in existence today can be modeled as 
  a finite state machine, as all real computers operate on finite resources. 
  Such a machine has a set of states, and a set of state transitions which are 
  affected by the input stream. Certain states are defined to be accepting 
  states. An input stream is fed into the machine one character at a time, and 
  the state transitions for the current state are compared to the input stream, 
  and if there is a matching transition the machine may enter a new state. If at 
  the end of the input stream the machine is in an accepting state, then the 
  whole input stream is accepted. </DD></DL>
<DL>
  <DT><A title="Nondeterministic finite state machine" 
  href="http://en.wikipedia.org/wiki/Nondeterministic_finite_state_machine">Nondeterministic 
  finite state machine</A> 
  <DD>Similarly called a nondeterministic finite automaton (NFA), it is another 
  simple model of computation, although its processing sequence is not uniquely 
  determined. It can be interpreted as taking multiple paths of computation 
  simultaneously through a finite number of states. However, it is proved that 
  any NFA is exactly reducible to an equivalent DFA. </DD></DL>
<DL>
  <DT><A title="Pushdown automaton" 
  href="http://en.wikipedia.org/wiki/Pushdown_automaton">Pushdown automaton</A> 
  <DD>Similar to the finite state machine, except that it has available an 
  execution stack, which is allowed to grow to arbitrary size. The state 
  transitions additionally specify whether to add a symbol to the stack, or to 
  remove a symbol from the stack. It is more powerful than a DFA due to its 
  infinite-memory stack, although only some information in the stack is ever 
  freely accessible. </DD></DL>
<DL>
  <DT><A title="Turing machine" 
  href="http://en.wikipedia.org/wiki/Turing_machine">Turing machine</A> 
  <DD>Also similar to the finite state machine, except that the input is 
  provided on an execution "tape", which the Turing machine can read from, write 
  to, or move back and forth past its read/write "head". The tape is allowed to 
  grow to arbitrary size. The Turing machine is capable of performing complex 
  calculations which can have arbitrary duration. This model is perhaps the most 
  important model of computation in computer science, as it simulates 
  computation in the absence of predefined resource limits. </DD></DL>
<DL>
  <DT><A class=mw-redirect title="Multi-tape Turing machine" 
  href="http://en.wikipedia.org/wiki/Multi-tape_Turing_machine">Multi-tape 
  Turing machine</A> 
  <DD>Here, there may be more than one tape; moreover there may be multiple 
  heads per tape. Surprisingly, any computation that can be performed by this 
  sort of machine can also be performed by an ordinary Turing machine, although 
  the latter may be slower or require a larger total region of its tape. 
</DD></DL>
<P><A id=Power_of_automata name=Power_of_automata></A></P>
<H2><SPAN class=editsection>[<A title="Edit section: Power of automata" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=3">edit</A>]</SPAN> 
<SPAN class=mw-headline>Power of automata</SPAN></H2>
<P>With these computational models in hand, we can determine what their limits 
are. That is, what classes of <A title="Formal language" 
href="http://en.wikipedia.org/wiki/Formal_language">languages</A> can they 
accept?</P>
<P><A id=Power_of_finite_state_machines 
name=Power_of_finite_state_machines></A></P>
<H3><SPAN class=editsection>[<A 
title="Edit section: Power of finite state machines" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=4">edit</A>]</SPAN> 
<SPAN class=mw-headline>Power of finite state machines</SPAN></H3>
<P>Computer scientists call any language that can be accepted by a finite state 
machine a <B><A title="Regular language" 
href="http://en.wikipedia.org/wiki/Regular_language">regular language</A></B>. 
Because of the restriction that the number of possible states in a finite state 
machine is finite, we can see that to find a language that is not regular, we 
must construct a language that would require an infinite number of states.</P>
<P>An example of such a language is the set of all strings consisting of the 
letters 'a' and 'b' which contain an equal number of the letter 'a' and 'b'. To 
see why this language cannot be correctly recognized by a finite state machine, 
assume first that such a machine <SPAN class=texhtml><I>M</I></SPAN> exists. 
<SPAN class=texhtml><I>M</I></SPAN> must have some number of states <SPAN 
class=texhtml><I>n</I></SPAN>. Now consider the string <SPAN 
class=texhtml><I>x</I></SPAN> consisting of <SPAN class=texhtml>(<I>n</I> + 
1)</SPAN> 'a's followed by <SPAN class=texhtml>(<I>n</I> + 1)</SPAN> 'b's.</P>
<P>As <SPAN class=texhtml><I>M</I></SPAN> reads in <SPAN 
class=texhtml><I>x</I></SPAN>, there must be some state in the machine that is 
repeated as it reads in the first series of 'a's, since there are <SPAN 
class=texhtml>(<I>n</I> + 1)</SPAN> 'a's and only <SPAN 
class=texhtml><I>n</I></SPAN> states by the <A title="Pigeonhole principle" 
href="http://en.wikipedia.org/wiki/Pigeonhole_principle">pigeonhole 
principle</A>. Call this state <SPAN class=texhtml><I>S</I></SPAN>, and further 
let <SPAN class=texhtml><I>d</I></SPAN> be the number of 'a's that our machine 
read in order to get from the first occurrence of <SPAN 
class=texhtml><I>S</I></SPAN> to some subsequent occurrence during the 'a' 
sequence. We know, then, that at that second occurrence of <SPAN 
class=texhtml><I>S</I></SPAN>, we can add in an additional <SPAN 
class=texhtml><I>d</I></SPAN> (where <SPAN class=texhtml><I>d</I> &gt; 0</SPAN>) 
'a's and we will be again at state <SPAN class=texhtml><I>S</I></SPAN>. This 
means that we know that a string of <SPAN class=texhtml>(<I>n</I> + <I>d</I> + 
1)</SPAN> 'a's must end up in the same state as the string of <SPAN 
class=texhtml>(<I>n</I> + 1)</SPAN> 'a's. This implies that if our machine 
accepts <SPAN class=texhtml><I>x</I></SPAN>, it must also accept the string of 
<SPAN class=texhtml>(<I>n</I> + <I>d</I> + 1)</SPAN> 'a's followed by <SPAN 
class=texhtml>(<I>n</I> + 1)</SPAN> 'b's, which is not in the language of 
strings containing an equal number of 'a's and 'b's. In other words, <SPAN 
class=texhtml><I>M</I></SPAN> cannot correctly distinguish between a string of 
equal number of 'a's and 'b's and a string with <SPAN class=texhtml>(<I>n</I> + 
<I>d</I> + 1)</SPAN> 'a's and <SPAN class=texhtml><I>n</I> + 1</SPAN> 'b's.</P>
<P>We know, therefore, that this language cannot be accepted correctly by any 
finite state machine, and is thus not a regular language. A more general form of 
this result is called the <A title="Pumping lemma for regular languages" 
href="http://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages">Pumping 
lemma for regular languages</A>, which can be used to show that broad classes of 
languages cannot be recognized by a finite state machine.</P>
<P><A id=Power_of_pushdown_automata name=Power_of_pushdown_automata></A></P>
<H3><SPAN class=editsection>[<A title="Edit section: Power of pushdown automata" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=5">edit</A>]</SPAN> 
<SPAN class=mw-headline>Power of pushdown automata</SPAN></H3>
<P>Computer scientists define a language that can be accepted by a <A 
title="Pushdown automaton" 
href="http://en.wikipedia.org/wiki/Pushdown_automaton">pushdown automaton</A> as 
a <B><A title="Context-free language" 
href="http://en.wikipedia.org/wiki/Context-free_language">Context-free 
language</A></B>, which can be specified as a <B><A title="Context-free grammar" 
href="http://en.wikipedia.org/wiki/Context-free_grammar">Context-free 
grammar</A></B>. The language consisting of strings with equal numbers of 'a's 
and 'b's, which we showed was not a regular language, can be decided by a 
push-down automaton. Also, in general, a push-down automaton can behave just 
like a finite-state machine, so it can decide any language which is regular. 
This model of computation is thus strictly more powerful than finite state 
machines.</P>
<P>However, it turns out there are languages that cannot be decided by push-down 
automaton either. The result is similar to that for regular expressions, and 
won't be detailed here. There exists a <A 
title="Pumping lemma for context-free languages" 
href="http://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages">Pumping 
lemma for context-free languages</A>. An example of such a language is the set 
of prime numbers.</P>
<P><A id=Power_of_Turing_machines name=Power_of_Turing_machines></A></P>
<H3><SPAN class=editsection>[<A title="Edit section: Power of Turing machines" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=6">edit</A>]</SPAN> 
<SPAN class=mw-headline>Power of Turing machines</SPAN></H3>
<P><A title="Turing machine" 
href="http://en.wikipedia.org/wiki/Turing_machine">Turing machines</A> can 
decide any context-free language, in addition to languages not decidable by a 
push-down automaton, such as the language consisting of prime numbers. It is 
therefore a strictly more powerful model of computation.</P>
<P>Because Turing machines have the ability to "back up" in their input tape, it 
is possible for a Turing machine to run for a long time in a way that is not 
possible with the other computation models previously described. It is possible 
to construct a Turing machine that will never finish running (halt) on some 
inputs. We say that a Turing machine can decide a language if it eventually will 
halt on all inputs and give an answer. A language that can be so decided is 
called a <B><A title="Recursive language" 
href="http://en.wikipedia.org/wiki/Recursive_language">recursive 
language</A></B>. We can further describe Turing machines that will eventually 
halt and give an answer for any input in a language, but which may run forever 
for input strings which are not in the language. Such Turing machines could tell 
us that a given string is in the language, but we may never be sure based on its 
behavior that a given string is not in a language, since it may run forever in 
such a case. A language which is accepted by such a Turing machine is called a 
<B><A title="Recursively enumerable language" 
href="http://en.wikipedia.org/wiki/Recursively_enumerable_language">recursively 
enumerable language</A></B>.</P>
<P>The Turing machine, it turns out, is an exceedingly powerful model of 
automata. Attempts to amend the definition of a Turing machine to produce a more 
powerful machine are surprisingly met with failure. For example, adding an extra 
tape to the Turing machine, giving it a 2-dimensional (or 3 or any-dimensional) 
infinite surface to work with can all be simulated by a Turing machine with the 
basic 1-dimensional tape. These models are thus not more powerful. In fact, a 
consequence of the <A class=mw-redirect title="Church-Turing thesis" 
href="http://en.wikipedia.org/wiki/Church-Turing_thesis">Church-Turing 
thesis</A> is that there is no reasonable model of computation which can decide 
languages that cannot be decided by a Turing machine.</P>
<P>The question to ask then is: do there exist languages which are recursively 
enumerable, but not recursive? And, furthermore, are there languages which are 
not even recursively enumerable?</P>
<P><A id=The_halting_problem name=The_halting_problem></A></P>
<H4><SPAN class=editsection>[<A title="Edit section: The halting problem" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=7">edit</A>]</SPAN> 
<SPAN class=mw-headline>The halting problem</SPAN></H4>
<DL>
  <DD>
  <DIV class="noprint relarticle mainarticle"><I>Main article: <A 
  title="Halting problem" 
  href="http://en.wikipedia.org/wiki/Halting_problem">Halting 
  problem</A></I></DIV></DD></DL>
<P>The halting problem is one of the most famous problems in computer science, 
because it has profound implications on the theory of computability and on how 
we use computers in everyday practice. The problem can be phrased:</P>
<DL>
  <DD><I>Given a description of a Turing machine and its initial input, 
  determine whether the program, when executed on this input, ever halts 
  (completes). The alternative is that it runs forever without halting.</I> 
</DD></DL>
<P>Here we are asking not a simple question about a prime number or a 
palindrome, but we are instead turning the tables and asking a Turing machine to 
answer a question about another Turing machine. It can be shown (See main 
article: <A title="Halting problem" 
href="http://en.wikipedia.org/wiki/Halting_problem">Halting problem</A>) that it 
is not possible to construct a Turing machine that can answer this question in 
all cases.</P>
<P>That is, the only general way to know for sure if a given program will halt 
on a particular input in all cases is simply to run it and see if it halts. If 
it does halt, then you know it halts. If it doesn't halt, however, you may never 
know if it will eventually halt. The language consisting of all Turing machine 
descriptions paired with all possible input streams on which those Turing 
machines will eventually halt, is not recursive. The halting problem is 
therefore called non-computable or <B><A title=Undecidable 
href="http://en.wikipedia.org/wiki/Undecidable">undecidable</A></B>.</P>
<P>An extension of the halting problem is called <A class=mw-redirect 
title="Rice's Theorem" 
href="http://en.wikipedia.org/wiki/Rice%27s_Theorem">Rice's Theorem</A>, which 
states that it is undecidable (in general) whether a given language possesses 
any specific nontrivial property.</P>
<P><A id=Beyond_recursive_languages name=Beyond_recursive_languages></A></P>
<H4><SPAN class=editsection>[<A title="Edit section: Beyond recursive languages" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=8">edit</A>]</SPAN> 
<SPAN class=mw-headline>Beyond recursive languages</SPAN></H4>
<P>The halting problem is easy to solve, however, if we allow that the Turing 
machine that decides it may run forever when given input which is a 
representation of a Turing machine that does not itself halt. The halting 
language is therefore recursively enumerable. It is possible to construct 
languages which are not even recursively enumerable, however.</P>
<P>A simple example of such a language is the complement of the halting 
language; that is the language consisting of all Turing machines paired with 
input strings where the Turing machines do <I>not</I> halt on their input. To 
see that this language is not recursively enumerable, imagine that we construct 
a Turing machine <SPAN class=texhtml><I>M</I></SPAN> which is able to give a 
definite answer for all such Turing machines, but that it may run forever on any 
Turing machine that does eventually halt. We can then construct another Turing 
machine <SPAN class=texhtml><I>M</I>'</SPAN> that simulates the operation of 
this machine, along with simulating directly the execution of the machine given 
in the input as well, by interleaving the execution of the two programs. Since 
the direct simulation will eventually halt if the program it is simulating 
halts, and since by assumption the simulation of <SPAN 
class=texhtml><I>M</I></SPAN> will eventually halt if the input program would 
never halt, we know that <SPAN class=texhtml><I>M</I>'</SPAN> will eventually 
have one of its parallel versions halt. <SPAN class=texhtml><I>M</I>'</SPAN> is 
thus a decider for the halting problem. We have previously shown, however, that 
the halting problem is undecidable. We have a contradiction, and we have thus 
shown that our assumption that <SPAN class=texhtml><I>M</I></SPAN> exists is 
incorrect. The complement of the halting language is therefore not recursively 
enumerable.</P>
<P><A id=Concurrency-based_models name=Concurrency-based_models></A></P>
<H2><SPAN class=editsection>[<A title="Edit section: Concurrency-based models" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=9">edit</A>]</SPAN> 
<SPAN class=mw-headline>Concurrency-based models</SPAN></H2>
<P>A number of computational models based on <A 
title="Concurrency (computer science)" 
href="http://en.wikipedia.org/wiki/Concurrency_(computer_science)">concurrency</A> 
have been developed, including the <A title="Parallel Random Access Machine" 
href="http://en.wikipedia.org/wiki/Parallel_Random_Access_Machine">Parallel 
Random Access Machine</A> and the <A title="Petri net" 
href="http://en.wikipedia.org/wiki/Petri_net">Petri net</A>. These models of 
concurrent computation still do not implement any mathematical functions that 
cannot be implemented by Turing machines.</P>
<P><A id=Unreasonable_models_of_computation 
name=Unreasonable_models_of_computation></A></P>
<H2><SPAN class=editsection>[<A 
title="Edit section: Unreasonable models of computation" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=10">edit</A>]</SPAN> 
<SPAN class=mw-headline>Unreasonable models of computation</SPAN></H2>
<P>The <A class=mw-redirect title="Church-Turing thesis" 
href="http://en.wikipedia.org/wiki/Church-Turing_thesis">Church-Turing 
thesis</A> conjectures that there is no reasonable model of computing that can 
compute more mathematical functions than a Turing machine. In this section we 
will explore some of the "unreasonable" ideas for computational models which 
violate this conjecture. Computer scientists have imagined many varieties of 
<B><A class=mw-redirect title=Hypercomputer 
href="http://en.wikipedia.org/wiki/Hypercomputer">hypercomputers</A></B>.</P>
<P><A id=Infinite_execution name=Infinite_execution></A></P>
<H3><SPAN class=editsection>[<A title="Edit section: Infinite execution" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=11">edit</A>]</SPAN> 
<SPAN class=mw-headline>Infinite execution</SPAN></H3>
<DL>
  <DD>
  <DIV class="noprint relarticle mainarticle"><I>Main article: <A 
  title="Zeno machine" href="http://en.wikipedia.org/wiki/Zeno_machine">Zeno 
  machine</A></I></DIV></DD></DL>
<P>Imagine a machine where each step of the computation requires half the time 
of the previous step. If we normalize to 1 time unit the amount of time required 
for the first step, the execution would require</P>
<DL>
  <DD><IMG class=tex alt="1 + {1 \over 2} + {1 \over 4} + \cdots" 
  src="ComputabilityTheory_files/5254134790a91115b3dbd14185e719c0.png"> </DD></DL>
<P>time to run. This infinite series converges to 2 time units, which means that 
this Turing machine can run an infinite execution in 2 time units. This machine 
is capable of deciding the halting problem by directly simulating the execution 
of the machine in question. By extension, any convergent series would work. 
Assuming that the series converges to a value <SPAN 
class=texhtml><I>n</I></SPAN>, the Turing machine would complete an infinite 
execution in <SPAN class=texhtml><I>n</I></SPAN> time units.</P>
<P><A id=Oracle_machines name=Oracle_machines></A></P>
<H3><SPAN class=editsection>[<A title="Edit section: Oracle machines" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=12">edit</A>]</SPAN> 
<SPAN class=mw-headline>Oracle machines</SPAN></H3>
<DL>
  <DD>
  <DIV class="noprint relarticle mainarticle"><I>Main article: <A 
  title="Oracle machine" 
  href="http://en.wikipedia.org/wiki/Oracle_machine">Oracle 
  machine</A></I></DIV></DD></DL>
<P>So-called Oracle machines have access to various "oracles" which provide the 
solution to specific undecidable problems. For example, the Turing machine may 
have a "halting oracle" which answers immediately whether a given Turing machine 
will ever halt on a given input. These machines are a central topic of study in 
<A title="Recursion theory" 
href="http://en.wikipedia.org/wiki/Recursion_theory">recursion theory</A>.</P>
<P><A id=Limits_of_hyper-computation name=Limits_of_hyper-computation></A></P>
<H3><SPAN class=editsection>[<A 
title="Edit section: Limits of hyper-computation" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=13">edit</A>]</SPAN> 
<SPAN class=mw-headline>Limits of hyper-computation</SPAN></H3>
<P>Even these machines, which seemingly represent the limit of automata that we 
could imagine, run into their own limitations. While each of them can solve the 
halting problem for a Turing machine, they cannot solve their own version of the 
halting problem. For example, an Oracle machine cannot answer the question of 
whether a given Oracle machine will ever halt.</P>
<P><A id=History_of_computability_theory 
name=History_of_computability_theory></A></P>
<H2><SPAN class=editsection>[<A 
title="Edit section: History of computability theory" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=14">edit</A>]</SPAN> 
<SPAN class=mw-headline>History of computability theory</SPAN></H2>
<P>The <A title="Lambda calculus" 
href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</A>, an 
important precursor to formal computability theory, was developed by <A 
title="Alonzo Church" href="http://en.wikipedia.org/wiki/Alonzo_Church">Alonzo 
Church</A> and <A title="Stephen Cole Kleene" 
href="http://en.wikipedia.org/wiki/Stephen_Cole_Kleene">Stephen Cole Kleene</A>. 
<A title="Alan Turing" href="http://en.wikipedia.org/wiki/Alan_Turing">Alan 
Turing</A> is most often considered the father of modern computer science, and 
laid many of the important foundations of computability and complexity theory, 
including the first description of the <A title="Turing machine" 
href="http://en.wikipedia.org/wiki/Turing_machine">Turing machine</A> (in <A 
class="external autonumber" 
title=http://web.comlab.ox.ac.uk/oucl/research/areas/ieg/e-library/sources/tp2-ie.pdf 
href="http://web.comlab.ox.ac.uk/oucl/research/areas/ieg/e-library/sources/tp2-ie.pdf" 
rel=nofollow>[1]</A>, 1936) as well as many of the important early results.</P>
<P><A id=See_also name=See_also></A></P>
<H2><SPAN class=editsection>[<A title="Edit section: See also" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=15">edit</A>]</SPAN> 
<SPAN class=mw-headline>See also</SPAN></H2>
<UL>
  <LI><A title="Automata theory" 
  href="http://en.wikipedia.org/wiki/Automata_theory">Automata theory</A> 
  <LI><A title="Abstract machine" 
  href="http://en.wikipedia.org/wiki/Abstract_machine">Abstract machine</A> 
  <LI><A title="List of undecidable problems" 
  href="http://en.wikipedia.org/wiki/List_of_undecidable_problems">List of 
  undecidable problems</A> 
  <LI><A title="Computational complexity theory" 
  href="http://en.wikipedia.org/wiki/Computational_complexity_theory">Computational 
  complexity theory</A> 
  <LI><A title="Computability logic" 
  href="http://en.wikipedia.org/wiki/Computability_logic">Computability 
  logic</A> 
  <LI><A title="List of important publications in computer science" 
  href="http://en.wikipedia.org/wiki/List_of_important_publications_in_computer_science#Computability">Important 
  publications in computability</A> </LI></UL>
<P><A id=References name=References></A></P>
<H2><SPAN class=editsection>[<A title="Edit section: References" 
href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit&amp;section=16">edit</A>]</SPAN> 
<SPAN class=mw-headline>References</SPAN></H2>
<UL>
  <LI><CITE class=book style="FONT-STYLE: normal"><A title="Michael Sipser" 
  href="http://en.wikipedia.org/wiki/Michael_Sipser">Michael Sipser</A> (1997). 
  <I>Introduction to the Theory of Computation</I>. PWS Publishing. <A 
  class=internal 
  href="http://en.wikipedia.org/wiki/Special:BookSources/053494728X">ISBN 
  0-534-94728-X</A>.</CITE><SPAN class=Z3988 
  title=ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Introduction+to+the+Theory+of+Computation&amp;rft.au=%5B%5BMichael+Sipser%5D%5D&amp;rft.date=1997&amp;rft.pub=PWS+Publishing><SPAN 
  style="DISPLAY: none">&nbsp;</SPAN></SPAN> Part Two: Computability Theory, 
  chapters 3–6, pp.123–222. 
  <LI><CITE class=book style="FONT-STYLE: normal"><A 
  title="Christos Papadimitriou" 
  href="http://en.wikipedia.org/wiki/Christos_Papadimitriou">Christos 
  Papadimitriou</A> (1993). <I>Computational Complexity</I>, 1st edition, 
  Addison Wesley. <A class=internal 
  href="http://en.wikipedia.org/wiki/Special:BookSources/0201530821">ISBN 
  0-201-53082-1</A>.</CITE><SPAN class=Z3988 
  title=ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Computational+Complexity&amp;rft.au=%5B%5BChristos+Papadimitriou%5D%5D&amp;rft.date=1993&amp;rft.edition=1st+edition&amp;rft.pub=Addison+Wesley><SPAN 
  style="DISPLAY: none">&nbsp;</SPAN></SPAN> Chapter 3: Computability, pp.57–70. 
  </LI></UL><!-- 
NewPP limit report
Preprocessor node count: 547/1000000
Post-expand include size: 2323/2048000 bytes
Template argument size: 948/2048000 bytes
Expensive parser function count: 0/500
--><!-- Saved in parser cache with key enwiki:pcache:idhash:442136-0!1!0!default!!en!2 and timestamp 20081018002655 -->
<DIV class=printfooter>Retrieved from "<A 
href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)">http://en.wikipedia.org/wiki/Computability_theory_(computer_science)</A>"</DIV>
<DIV class=catlinks id=catlinks>
<DIV id=mw-normal-catlinks><A title=Special:Categories 
href="http://en.wikipedia.org/wiki/Special:Categories">Categories</A>: <SPAN 
dir=ltr><A title="Category:Theory of computation" 
href="http://en.wikipedia.org/wiki/Category:Theory_of_computation">Theory of 
computation</A></SPAN></DIV></DIV><!-- end content -->
<DIV class=visualClear></DIV></DIV></DIV></DIV>
<DIV id=column-one>
<DIV class=portlet id=p-cactions>
<H5>Views</H5>
<DIV class=pBody>
<UL>
  <LI class=selected id=ca-nstab-main><A title="View the content page [c]" 
  accessKey=c 
  href="http://en.wikipedia.org/wiki/Computability_theory_(computer_science)">Article</A> 

  <LI id=ca-talk><A title="Discussion about the content page [t]" accessKey=t 
  href="http://en.wikipedia.org/wiki/Talk:Computability_theory_(computer_science)">Discussion</A> 

  <LI id=ca-edit><A 
  title="You can edit this page. &#10;Please use the preview button before saving. [e]" 
  accessKey=e 
  href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=edit">Edit 
  this page</A> 
  <LI id=ca-history><A title="Past versions of this page [h]" accessKey=h 
  href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;action=history">History</A> 
  </LI></UL></DIV></DIV>
<DIV class=portlet id=p-personal>
<H5>Personal tools</H5>
<DIV class=pBody>
<UL>
  <LI id=pt-login><A 
  title="You are encouraged to log in; however, it is not mandatory. [o]" 
  accessKey=o 
  href="http://en.wikipedia.org/w/index.php?title=Special:UserLogin&amp;returnto=Computability_theory_(computer_science)">Log 
  in / create account</A> </LI></UL></DIV></DIV>
<DIV class=portlet id=p-logo><A title="Visit the main page [z]" 
style="BACKGROUND-IMAGE: url(http://upload.wikimedia.org/wikipedia/en/b/bc/Wiki.png)" 
accessKey=z href="http://en.wikipedia.org/wiki/Main_Page"></A></DIV>
<SCRIPT type=text/javascript> if (window.isMSIE55) fixalpha(); </SCRIPT>

<DIV class="generated-sidebar portlet" id=p-navigation>
<H5>Navigation</H5>
<DIV class=pBody>
<UL>
  <LI id=n-mainpage-description><A title="Visit the main page [z]" accessKey=z 
  href="http://en.wikipedia.org/wiki/Main_Page">Main page</A> 
  <LI id=n-contents><A title="Guides to browsing Wikipedia" 
  href="http://en.wikipedia.org/wiki/Portal:Contents">Contents</A> 
  <LI id=n-featuredcontent><A title="Featured content — the best of Wikipedia" 
  href="http://en.wikipedia.org/wiki/Portal:Featured_content">Featured 
  content</A> 
  <LI id=n-currentevents><A 
  title="Find background information on current events" 
  href="http://en.wikipedia.org/wiki/Portal:Current_events">Current events</A> 
  <LI id=n-randompage><A title="Load a random article [x]" accessKey=x 
  href="http://en.wikipedia.org/wiki/Special:Random">Random article</A> 
</LI></UL></DIV></DIV>
<DIV class=portlet id=p-search>
<H5><LABEL for=searchInput>Search</LABEL></H5>
<DIV class=pBody id=searchBody>
<FORM id=searchform action=/wiki/Special:Search>
<DIV><INPUT id=searchInput title="Search Wikipedia [f]" accessKey=f name=search> 
<INPUT class=searchButton id=searchGoButton title="Go to a page with this exact name if one exists" type=submit value=Go name=go>&nbsp; 
<INPUT class=searchButton id=mw-searchButton title="Search Wikipedia for this text" type=submit value=Search name=fulltext> 
</DIV></FORM></DIV></DIV>
<DIV class="generated-sidebar portlet" id=p-interaction>
<H5>Interaction</H5>
<DIV class=pBody>
<UL>
  <LI id=n-aboutsite><A title="Find out about Wikipedia" 
  href="http://en.wikipedia.org/wiki/Wikipedia:About">About Wikipedia</A> 
  <LI id=n-portal><A 
  title="About the project, what you can do, where to find things" 
  href="http://en.wikipedia.org/wiki/Wikipedia:Community_portal">Community 
  portal</A> 
  <LI id=n-recentchanges><A title="The list of recent changes in the wiki [r]" 
  accessKey=r href="http://en.wikipedia.org/wiki/Special:RecentChanges">Recent 
  changes</A> 
  <LI id=n-contact><A title="How to contact Wikipedia" 
  href="http://en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact Wikipedia</A> 

  <LI id=n-sitesupport><A title="Support us" 
  href="http://wikimediafoundation.org/wiki/Donate">Donate to Wikipedia</A> 
  <LI id=n-help><A title="Guidance on how to use and edit Wikipedia" 
  href="http://en.wikipedia.org/wiki/Help:Contents">Help</A> 
</LI></UL></DIV></DIV>
<DIV class=portlet id=p-tb>
<H5>Toolbox</H5>
<DIV class=pBody>
<UL>
  <LI id=t-whatlinkshere><A 
  title="List of all English Wikipedia pages containing links to this page [j]" 
  accessKey=j 
  href="http://en.wikipedia.org/wiki/Special:WhatLinksHere/Computability_theory_(computer_science)">What 
  links here</A> 
  <LI id=t-recentchangeslinked><A 
  title="Recent changes in pages linked from this page [k]" accessKey=k 
  href="http://en.wikipedia.org/wiki/Special:RecentChangesLinked/Computability_theory_(computer_science)">Related 
  changes</A> 
  <LI id=t-upload><A title="Upload files [u]" accessKey=u 
  href="http://en.wikipedia.org/wiki/Wikipedia:Upload">Upload file</A> 
  <LI id=t-specialpages><A title="List of all special pages [q]" accessKey=q 
  href="http://en.wikipedia.org/wiki/Special:SpecialPages">Special pages</A> 
  <LI id=t-print><A title="Printable version of this page [p]" accessKey=p 
  href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;printable=yes">Printable 
  version</A> 
  <LI id=t-permalink><A title="Permanent link to this version of the page" 
  href="http://en.wikipedia.org/w/index.php?title=Computability_theory_(computer_science)&amp;oldid=224042373">Permanent 
  link</A>
  <LI id=t-cite><A 
  href="http://en.wikipedia.org/w/index.php?title=Special:Cite&amp;page=Computability_theory_(computer_science)&amp;id=224042373">Cite 
  this page</A> </LI></UL></DIV></DIV>
<DIV class=portlet id=p-lang>
<H5>Languages</H5>
<DIV class=pBody>
<UL>
  <LI class=interwiki-ar><A 
  href="http://ar.wikipedia.org/wiki/%D9%86%D8%B8%D8%B1%D9%8A%D8%A9_%D8%A7%D9%84%D8%AD%D8%A7%D8%B3%D9%88%D8%A8%D9%8A%D8%A9">العربية</A> 

  <LI class=interwiki-ca><A 
  href="http://ca.wikipedia.org/wiki/Teoria_de_la_computabilitat">Català</A> 
  <LI class=interwiki-cs><A 
  href="http://cs.wikipedia.org/wiki/Teorie_vy%C4%8D%C3%ADslitelnosti">Česky</A> 

  <LI class=interwiki-de><A 
  href="http://de.wikipedia.org/wiki/Berechenbarkeitstheorie">Deutsch</A> 
  <LI class=interwiki-es><A 
  href="http://es.wikipedia.org/wiki/Teor%C3%ADa_de_la_computabilidad">Español</A> 

  <LI class=interwiki-fa><A 
  href="http://fa.wikipedia.org/wiki/%D9%86%D8%B8%D8%B1%DB%8C%D9%87_%D9%85%D8%AD%D8%A7%D8%B3%D8%A8%D9%87%E2%80%8C%D9%BE%D8%B0%DB%8C%D8%B1%DB%8C">فارسی</A> 

  <LI class=interwiki-fr><A 
  href="http://fr.wikipedia.org/wiki/Calculabilit%C3%A9">Français</A> 
  <LI class=interwiki-ko><A 
  href="http://ko.wikipedia.org/wiki/%EA%B3%84%EC%82%B0_%EA%B0%80%EB%8A%A5%EC%84%B1_%EC%9D%B4%EB%A1%A0">한국어</A> 

  <LI class=interwiki-hr><A 
  href="http://hr.wikipedia.org/wiki/Teorija_izra%C4%8Dunljivosti_(ra%C4%8Dunarstvo)">Hrvatski</A> 

  <LI class=interwiki-it><A 
  href="http://it.wikipedia.org/wiki/Teoria_della_calcolabilit%C3%A0">Italiano</A> 

  <LI class=interwiki-he><A 
  href="http://he.wikipedia.org/wiki/%D7%97%D7%99%D7%A9%D7%95%D7%91%D7%99%D7%95%D7%AA">עברית</A> 

  <LI class=interwiki-nl><A 
  href="http://nl.wikipedia.org/wiki/Berekenbaarheid">Nederlands</A> 
  <LI class=interwiki-ja><A 
  href="http://ja.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E5%8F%AF%E8%83%BD%E6%80%A7%E7%90%86%E8%AB%96">日本語</A> 

  <LI class=interwiki-pl><A 
  href="http://pl.wikipedia.org/wiki/Teoria_obliczalno%C5%9Bci">Polski</A> 
  <LI class=interwiki-pt><A 
  href="http://pt.wikipedia.org/wiki/Computabilidade">Português</A> 
  <LI class=interwiki-ru><A 
  href="http://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8">Русский</A> 

  <LI class=interwiki-simple><A 
  href="http://simple.wikipedia.org/wiki/Computability_theory">Simple 
  English</A> 
  <LI class=interwiki-th><A 
  href="http://th.wikipedia.org/wiki/%E0%B8%97%E0%B8%A4%E0%B8%A9%E0%B8%8E%E0%B8%B5%E0%B8%81%E0%B8%B2%E0%B8%A3%E0%B8%84%E0%B8%B3%E0%B8%99%E0%B8%A7%E0%B8%93%E0%B9%84%E0%B8%94%E0%B9%89">ไทย</A> 
  </LI></UL></DIV></DIV></DIV><!-- end of the left (by default at least) column -->
<DIV class=visualClear></DIV>
<DIV id=footer>
<DIV id=f-poweredbyico><A href="http://www.mediawiki.org/"><IMG 
alt="Powered by MediaWiki" 
src="ComputabilityTheory_files/poweredby_mediawiki_88x31.png"></A></DIV>
<DIV id=f-copyrightico><A href="http://wikimediafoundation.org/"><IMG 
alt="Wikimedia Foundation" src="ComputabilityTheory_files/wikimedia-button.png" 
border=0></A></DIV>
<UL id=f-list>
  <LI id=lastmod>This page was last modified on 7 July 2008, at 01:39. 
  <LI id=copyright>All text is available under the terms of the <A 
  class=internal title="Wikipedia:Text of the GNU Free Documentation License" 
  href="http://en.wikipedia.org/wiki/Wikipedia:Text_of_the_GNU_Free_Documentation_License">GNU 
  Free Documentation License</A>. (See <B><A class=internal 
  title=Wikipedia:Copyrights 
  href="http://en.wikipedia.org/wiki/Wikipedia:Copyrights">Copyrights</A></B> 
  for details.) <BR>Wikipedia® is a registered trademark of the <A 
  href="http://www.wikimediafoundation.org/">Wikimedia Foundation, Inc</A>., a 
  U.S. registered <A class=internal title=501(c)(3) 
  href="http://en.wikipedia.org/wiki/501%28c%29#501.28c.29.283.29">501(c)(3)</A> 
  <A 
  href="http://wikimediafoundation.org/wiki/Deductibility_of_donations">tax-deductible</A> 
  <A class=internal title="Non-profit organization" 
  href="http://en.wikipedia.org/wiki/Non-profit_organization">nonprofit</A> <A 
  title="Charitable organization" 
  href="http://en.wikipedia.org/wiki/Charitable_organization">charity</A>.<BR>
  <LI id=privacy><A title="wikimedia:Privacy policy" 
  href="http://wikimediafoundation.org/wiki/Privacy_policy">Privacy policy</A> 
  <LI id=about><A title=Wikipedia:About 
  href="http://en.wikipedia.org/wiki/Wikipedia:About">About Wikipedia</A> 
  <LI id=disclaimer><A title="Wikipedia:General disclaimer" 
  href="http://en.wikipedia.org/wiki/Wikipedia:General_disclaimer">Disclaimers</A> 
  </LI></UL></DIV></DIV>
<SCRIPT type=text/javascript>if (window.runOnloadHook) runOnloadHook();</SCRIPT>
<!-- Served by srv167 in 0.087 secs. --></BODY></HTML>
